# 보안/인증 문서 (Security Spec)

## 1. JWT 토큰 발급 및 검증 구조

### 1.1 JWT 토큰 개요

카탈로깅 시스템은 JWT (JSON Web Token) 기반 인증을 사용합니다.

**JWT 구조**:
```
eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxIiwiaWF0IjoxNzMxMDQ4MDAwLCJleHAiOjE3MzExMzQ0MDB9.signature
│                      │                                                                    │
Header                 Payload                                                              Signature
```

**Header**:
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

**Payload**:
```json
{
  "sub": "1",                    // 사용자 ID
  "iat": 1731048000,             // 발급 시간
  "exp": 1731134400              // 만료 시간 (24시간 후)
}
```

**Signature**:
```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret_key
)
```

### 1.2 JWT 토큰 발급 (User API - Spring Boot)

**JwtTokenProvider.java**:
```java
@Component
public class JwtTokenProvider {
    // JWT 시크릿 키 (환경 변수에서 로드)
    private final SecretKey key;
    
    // 토큰 유효 기간: 24시간
    private final long tokenValidityInMilliseconds = 86400000;
    
    public JwtTokenProvider(@Value("${jwt.secret}") String secret) {
        this.key = Keys.hmacShaKeyFor(secret.getBytes());
    }
    
    // JWT 토큰 생성
    public String createToken(String userId) {
        Date now = new Date();
        Date validity = new Date(now.getTime() + tokenValidityInMilliseconds);
        
        return Jwts.builder()
            .setSubject(userId)                    // 사용자 ID
            .setIssuedAt(now)                      // 발급 시간
            .setExpiration(validity)               // 만료 시간
            .signWith(key, SignatureAlgorithm.HS256)  // 서명
            .compact();
    }
    
    // 토큰에서 사용자 ID 추출
    public String getUserId(String token) {
        return Jwts.parserBuilder()
            .setSigningKey(key)
            .build()
            .parseClaimsJws(token)
            .getBody()
            .getSubject();
    }
    
    // 토큰 유효성 검증
    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }
}
```

### 1.3 JWT 토큰 검증 (Catalog API - FastAPI)

**app/core/security.py**:
```python
import jwt
from fastapi import Header, HTTPException
from typing import Optional
from app.core.config import settings

async def get_current_user_id(
    authorization: Optional[str] = Header(None)
) -> str:
    """JWT 토큰에서 사용자 ID 추출 (필수 인증)"""
    
    # Authorization 헤더 확인
    if not authorization or not authorization.startswith("Bearer "):
        raise HTTPException(
            status_code=401,
            detail="인증 토큰이 필요합니다"
        )
    
    # Bearer 토큰 추출
    token = authorization.split(" ")[1]
    
    try:
        # JWT 토큰 검증 (User API와 동일한 시크릿 키 사용)
        payload = jwt.decode(
            token,
            settings.JWT_SECRET_KEY,
            algorithms=[settings.JWT_ALGORITHM]
        )
        
        # 사용자 ID 추출
        user_id = payload.get("sub")
        if not user_id:
            raise HTTPException(
                status_code=401,
                detail="유효하지 않은 토큰"
            )
        
        return str(user_id)
        
    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=401,
            detail="토큰이 만료되었습니다"
        )
    except jwt.InvalidTokenError:
        raise HTTPException(
            status_code=401,
            detail="유효하지 않은 토큰"
        )
```

## 2. 마이크로서비스 간 인증 연동

### 2.1 통합 인증 구조

```
┌─────────────────────────────────────────────────────────┐
│                    Flutter Client                       │
│  - JWT 토큰을 SharedPreferences에 저장                  │
│  - 모든 API 요청에 Authorization 헤더 자동 포함         │
└─────────────────────────────────────────────────────────┘
                    │                    │
        ┌───────────┘                    └───────────┐
        │                                            │
        ▼                                            ▼
┌──────────────────┐                      ┌──────────────────┐
│   User API       │                      │  Catalog API     │
│  (Spring Boot)   │                      │   (FastAPI)      │
│                  │                      │                  │
│ JWT 토큰 발급    │                      │ JWT 토큰 검증    │
│ - createToken()  │                      │ - jwt.decode()   │
│ - HS256          │                      │ - HS256          │
│ - 24시간 유효    │                      │ - user_id 추출   │
│                  │                      │                  │
│ 시크릿 키:       │◄────동일 키────────►│ 시크릿 키:       │
│ "jwt-secret"     │                      │ "jwt-secret"     │
└──────────────────┘                      └──────────────────┘
```

### 2.2 시크릿 키 관리

**User API (application.yml)**:
```yaml
jwt:
  secret: ${your-jwt-secret-key}
  expiration: 86400000  # 24시간
```

**Catalog API (.env)**:
```env
JWT_SECRET_KEY=your-jwt-secret-key
JWT_ALGORITHM=HS256
```

**중요**: 두 서비스가 동일한 시크릿 키를 사용해야 합니다.

### 2.3 인증 흐름

```
1. Flutter → User API: POST /api/auth/dev-login
   { email, nickname }

2. User API: 사용자 조회/생성
   - UserService.findOrCreateDevUser()

3. User API: JWT 토큰 생성
   - JwtTokenProvider.createToken(userId)
   - Payload: { sub: "1", iat: ..., exp: ... }

4. User API → Flutter: 
   { accessToken: "eyJ...", user: {...} }

5. Flutter: 토큰 저장
   - SharedPreferences.setString('jwt_token', token)

6. Flutter → Catalog API: GET /api/user-catalogs/my-catalogs
   Authorization: Bearer eyJ...

7. Catalog API: 토큰 검증
   - get_current_user_id()
   - jwt.decode(token, SECRET_KEY, HS256)
   - user_id = payload['sub']

8. Catalog API: 사용자 데이터 조회
   - SELECT * FROM catalogs WHERE user_id = ?

9. Catalog API → Flutter:
   [{ catalog_id, title, ... }]
```

## 3. 권한 관리

### 3.1 데이터 접근 제어

**원칙**: 사용자는 자신의 데이터만 접근 가능

**구현**:
```python
# Catalog API - 카탈로그 수정
@router.put("/{catalog_id}")
async def update_catalog(
    catalog_id: str,
    catalog: CatalogUpdate,
    user_id: str = Depends(get_current_user_id),
    db: Session = Depends(get_db)
):
    # 카탈로그 조회
    db_catalog = db.query(CatalogDB).filter(
        CatalogDB.catalog_id == catalog_id
    ).first()
    
    if not db_catalog:
        raise HTTPException(status_code=404, detail="카탈로그를 찾을 수 없습니다")
    
    # 소유자 확인
    if db_catalog.user_id != user_id:
        raise HTTPException(status_code=403, detail="권한이 없습니다")
    
    # 수정 처리...
```

### 3.2 공개/비공개 설정

**카탈로그 공개 범위**:
- `public`: 모든 사용자가 조회 가능
- `private`: 소유자만 조회 가능

**구현**:
```python
# 공개 카탈로그 조회
@router.get("/public")
async def get_public_catalogs(
    category: Optional[str] = None,
    user_id: Optional[str] = Depends(get_optional_user_id),
    db: Session = Depends(get_db)
):
    query = db.query(CatalogDB).filter(
        CatalogDB.visibility == "public"
    )
    
    # 자신의 카탈로그 제외
    if user_id:
        query = query.filter(CatalogDB.user_id != user_id)
    
    # 카테고리 필터
    if category:
        query = query.filter(CatalogDB.category == category)
    
    return query.all()
```

### 3.3 권한 레벨

| 작업 | 소유자 | 다른 사용자 (공개) | 다른 사용자 (비공개) |
|------|--------|-------------------|---------------------|
| 카탈로그 조회 | ✅ | ✅ | ❌ |
| 카탈로그 수정 | ✅ | ❌ | ❌ |
| 카탈로그 삭제 | ✅ | ❌ | ❌ |
| 아이템 조회 | ✅ | ✅ | ❌ |
| 아이템 수정 | ✅ | ❌ | ❌ |
| 아이템 보유 상태 토글 | ✅ | ❌ | ❌ |
| 카탈로그 저장 (복사) | ❌ | ✅ | ❌ |

## 4. 보안 고려사항

### 4.1 토큰 보안

**저장**:
- ✅ SharedPreferences (Flutter)
- ✅ 향후: Secure Storage 사용 권장
- ❌ LocalStorage (웹에서 XSS 취약)

**전송**:
- ✅ HTTPS (프로덕션 필수)
- ✅ Authorization 헤더
- ❌ URL 파라미터 (로그에 노출)

**만료**:
- 24시간 후 자동 만료
- 만료 시 재로그인 필요
- 향후: Refresh Token 도입 고려

### 4.2 SQL Injection 방지

**ORM 사용**:
- User API: JPA/Hibernate
- Catalog API: SQLAlchemy

**파라미터 바인딩**:
```python
# ✅ 안전한 방법
db.query(CatalogDB).filter(CatalogDB.user_id == user_id).all()

# ❌ 위험한 방법 (사용 금지)
db.execute(f"SELECT * FROM catalogs WHERE user_id = '{user_id}'")
```

### 4.3 XSS (Cross-Site Scripting) 방지

**JSON 응답**:
- Content-Type: application/json
- 자동 이스케이프 처리

**입력 검증**:
```python
# Pydantic 모델로 입력 검증
class CatalogCreate(BaseModel):
    title: str = Field(..., min_length=1, max_length=200)
    description: str = Field(..., min_length=1)
    category: str = Field(default="미분류", max_length=100)
```

### 4.4 CORS (Cross-Origin Resource Sharing)

**개발 환경**:
```python
# 모든 Origin 허용
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

**프로덕션 환경**:
```python
# 특정 도메인만 허용
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "https://cataloging.app",
        "https://www.cataloging.app"
    ],
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "PATCH", "DELETE"],
    allow_headers=["Authorization", "Content-Type"],
)
```

### 4.5 Rate Limiting

**향후 구현**:
```python
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)

@app.post("/api/auth/dev-login")
@limiter.limit("5/minute")  # 분당 5회 제한
async def dev_login(request: Request, ...):
    ...
```

### 4.6 민감 정보 보호

**로깅**:
```python
# ✅ 안전한 로깅
logger.info(f"사용자 로그인: user_id={user_id}")

# ❌ 위험한 로깅 (사용 금지)
logger.info(f"JWT 토큰: {token}")
logger.info(f"비밀번호: {password}")
```

**에러 응답**:
```python
# ✅ 일반적인 에러 메시지
raise HTTPException(status_code=401, detail="인증 실패")

# ❌ 상세한 에러 메시지 (사용 금지)
raise HTTPException(status_code=401, detail=f"사용자 {user_id}를 찾을 수 없습니다")
```

## 5. OAuth2 소셜 로그인 (향후 구현)

### 5.1 Google OAuth2

**Spring Security 설정**:
```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: ${GOOGLE_CLIENT_ID}
            client-secret: ${GOOGLE_CLIENT_SECRET}
            scope:
              - openid
              - profile
              - email
```

**OAuth2 흐름**:
```
1. Flutter → User API: GET /api/auth/login/google
2. User API → Flutter: { loginUrl: "https://accounts.google.com/..." }
3. Flutter: 브라우저에서 Google 로그인
4. Google → User API: /login/oauth2/code/google?code=...
5. User API: 사용자 정보 추출 및 저장
6. User API: JWT 토큰 생성
7. User API → Flutter: { accessToken, user }
```

### 5.2 Naver OAuth2

**Spring Security 설정**:
```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          naver:
            client-id: ${NAVER_CLIENT_ID}
            client-secret: ${NAVER_CLIENT_SECRET}
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}"
        provider:
          naver:
            authorization-uri: https://nid.naver.com/oauth2.0/authorize
            token-uri: https://nid.naver.com/oauth2.0/token
            user-info-uri: https://openapi.naver.com/v1/nid/me
            user-name-attribute: response
```

## 6. 보안 체크리스트

### 6.1 개발 환경

- [x] JWT 토큰 기반 인증
- [x] 사용자별 데이터 격리
- [x] ORM 사용 (SQL Injection 방지)
- [x] 입력 데이터 검증
- [x] 에러 메시지 일반화
- [ ] HTTPS (로컬 환경에서는 HTTP)
- [ ] Rate Limiting
- [ ] Secure Storage (현재 SharedPreferences)

### 6.2 프로덕션 환경 (향후)

- [ ] HTTPS 필수
- [ ] 환경 변수로 시크릿 관리
- [ ] CORS 특정 도메인만 허용
- [ ] Rate Limiting 적용
- [ ] Secure Storage 사용
- [ ] 로그 모니터링
- [ ] 정기적인 보안 감사
- [ ] 토큰 갱신 (Refresh Token)

## 7. 보안 사고 대응

### 7.1 토큰 탈취 시

1. 시크릿 키 변경
2. 모든 사용자 재로그인 요구
3. 로그 분석 및 피해 범위 파악

### 7.2 데이터 유출 시

1. 즉시 서비스 중단
2. 유출 경로 차단
3. 사용자 통지
4. 보안 패치 적용

### 7.3 DDoS 공격 시

1. Rate Limiting 강화
2. CloudFlare 등 CDN 활용
3. 의심스러운 IP 차단
