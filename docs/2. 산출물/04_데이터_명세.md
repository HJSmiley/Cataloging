# 데이터 명세 (Data & ERD)

## 1. 데이터베이스 개요

카탈로깅 시스템은 두 개의 독립적인 데이터베이스를 사용합니다:
- **User API**: H2 인메모리 데이터베이스 (회원 정보)
- **Catalog API**: SQLite 파일 데이터베이스 (카탈로그/아이템 정보)

## 2. User API 데이터베이스 (H2)

### 2.1 users 테이블

사용자 계정 정보를 저장합니다.

| 컬럼명 | 데이터 타입 | 제약 조건 | 설명 |
|--------|------------|----------|------|
| id | BIGINT | PK, AUTO_INCREMENT | 사용자 고유 ID (JWT sub 클레임) |
| provider | VARCHAR(50) | NOT NULL | OAuth2 제공자 (google, naver, dev) |
| provider_id | VARCHAR(255) | NOT NULL, UNIQUE | 제공자별 고유 식별자 |
| email | VARCHAR(255) | NOT NULL | 이메일 주소 |
| nickname | VARCHAR(100) | NOT NULL | 사용자 닉네임 |
| introduction | TEXT | NULL | 자기소개 (긴 텍스트) |
| profile_image | VARCHAR(500) | NULL | 프로필 이미지 URL |
| status | VARCHAR(20) | NOT NULL, DEFAULT 'ACTIVE' | 사용자 상태 (ACTIVE, INACTIVE, DELETED) |
| created_at | TIMESTAMP | NOT NULL, DEFAULT CURRENT_TIMESTAMP | 계정 생성 시간 |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT CURRENT_TIMESTAMP | 마지막 수정 시간 |

**인덱스**:
- PRIMARY KEY: id
- UNIQUE INDEX: provider_id
- INDEX: email

**예시 데이터**:
```sql
INSERT INTO users (id, provider, provider_id, email, nickname, status, created_at, updated_at)
VALUES (1, 'dev', 'dev_user@example.com', 'user@example.com', '테스트사용자', 'ACTIVE', NOW(), NOW());
```

## 3. Catalog API 데이터베이스 (SQLite)

### 3.1 catalogs 테이블

사용자가 생성한 수집 카탈로그 정보를 저장합니다.

| 컬럼명 | 데이터 타입 | 제약 조건 | 설명 |
|--------|------------|----------|------|
| catalog_id | VARCHAR(36) | PK | UUID 기반 고유 ID |
| user_id | VARCHAR(50) | NOT NULL, INDEX | 카탈로그 소유자 ID (JWT에서 추출) |
| title | VARCHAR(200) | NOT NULL | 카탈로그 제목 |
| description | TEXT | NOT NULL | 카탈로그 설명 |
| category | VARCHAR(100) | DEFAULT '미분류' | 카테고리 분류 |
| tags | JSON | DEFAULT '[]' | 태그 배열 (JSON 형태) |
| visibility | VARCHAR(20) | DEFAULT 'public' | 공개 설정 (public/private) |
| thumbnail_url | VARCHAR(500) | NULL | 썸네일 이미지 URL |
| created_at | TIMESTAMP | DEFAULT CURRENT_TIMESTAMP | 생성 시간 (KST) |
| updated_at | TIMESTAMP | DEFAULT CURRENT_TIMESTAMP | 수정 시간 (KST) |

**인덱스**:
- PRIMARY KEY: catalog_id
- INDEX: user_id
- INDEX: visibility

**예시 데이터**:
```sql
INSERT INTO catalogs (catalog_id, user_id, title, description, category, tags, visibility, created_at, updated_at)
VALUES ('550e8400-e29b-41d4-a716-446655440000', '1', '내 피규어 컬렉션', '애니메이션 피규어 모음', '피규어', '["애니메이션", "수집"]', 'public', datetime('now'), datetime('now'));
```

### 3.2 items 테이블

카탈로그에 속한 개별 수집품 정보를 저장합니다.

| 컬럼명 | 데이터 타입 | 제약 조건 | 설명 |
|--------|------------|----------|------|
| item_id | VARCHAR(36) | PK | UUID 기반 고유 ID |
| catalog_id | VARCHAR(36) | NOT NULL, INDEX | 소속 카탈로그 ID (외래키 역할) |
| name | VARCHAR(200) | NOT NULL | 아이템명 |
| description | TEXT | NOT NULL | 아이템 설명 |
| image_url | VARCHAR(500) | NULL | 아이템 이미지 URL |
| user_fields | JSON | DEFAULT '{}' | 사용자 정의 필드 (JSON 형태) |
| created_at | TIMESTAMP | DEFAULT CURRENT_TIMESTAMP | 생성 시간 (KST) |
| updated_at | TIMESTAMP | DEFAULT CURRENT_TIMESTAMP | 수정 시간 (KST) |

**인덱스**:
- PRIMARY KEY: item_id
- INDEX: catalog_id

**예시 데이터**:
```sql
INSERT INTO items (item_id, catalog_id, name, description, image_url, user_fields, created_at, updated_at)
VALUES ('660e8400-e29b-41d4-a716-446655440001', '550e8400-e29b-41d4-a716-446655440000', '하츠네 미쿠 피규어', '1/8 스케일 피규어', '/uploads/miku.jpg', '{"제조사": "굿스마일컴퍼니", "시리즈": "하츠네 미쿠"}', datetime('now'), datetime('now'));
```

### 3.3 user_item_status 테이블

사용자별 아이템 보유 상태를 추적합니다.

| 컬럼명 | 데이터 타입 | 제약 조건 | 설명 |
|--------|------------|----------|------|
| id | INTEGER | PK, AUTO_INCREMENT | 자동 증가 ID |
| user_id | VARCHAR(50) | NOT NULL, INDEX | 사용자 ID |
| item_id | VARCHAR(36) | NOT NULL, INDEX | 아이템 ID |
| owned | BOOLEAN | DEFAULT FALSE | 보유 여부 (True: 보유, False: 미보유) |
| created_at | TIMESTAMP | DEFAULT CURRENT_TIMESTAMP | 생성 시간 (KST) |
| updated_at | TIMESTAMP | DEFAULT CURRENT_TIMESTAMP | 수정 시간 (KST) |

**인덱스**:
- PRIMARY KEY: id
- INDEX: user_id
- INDEX: item_id
- UNIQUE INDEX: (user_id, item_id) - 한 사용자의 한 아이템에 대해 하나의 상태만 존재

**예시 데이터**:
```sql
INSERT INTO user_item_status (user_id, item_id, owned, created_at, updated_at)
VALUES ('1', '660e8400-e29b-41d4-a716-446655440001', TRUE, datetime('now'), datetime('now'));
```

### 3.4 user_catalogs 테이블

사용자가 저장한 카탈로그 관계를 추적합니다 (카탈로그 복사 기능).

| 컬럼명 | 데이터 타입 | 제약 조건 | 설명 |
|--------|------------|----------|------|
| id | INTEGER | PK, AUTO_INCREMENT | 자동 증가 ID |
| user_id | VARCHAR(50) | NOT NULL, INDEX | 저장한 사용자 ID |
| original_catalog_id | VARCHAR(36) | NOT NULL, INDEX | 원본 카탈로그 ID |
| copied_catalog_id | VARCHAR(36) | INDEX | 복사본 카탈로그 ID (내 컬렉션용) |
| saved_at | TIMESTAMP | DEFAULT CURRENT_TIMESTAMP | 저장 시간 (KST) |

**인덱스**:
- PRIMARY KEY: id
- INDEX: user_id
- INDEX: original_catalog_id
- INDEX: copied_catalog_id
- UNIQUE INDEX: (user_id, original_catalog_id) - 한 사용자가 같은 원본 카탈로그를 중복 저장하지 않도록 제약

**예시 데이터**:
```sql
INSERT INTO user_catalogs (user_id, original_catalog_id, copied_catalog_id, saved_at)
VALUES ('1', '550e8400-e29b-41d4-a716-446655440000', '770e8400-e29b-41d4-a716-446655440002', datetime('now'));
```

## 4. ERD (Entity Relationship Diagram)

### 4.1 전체 ERD

```
┌─────────────────────────────────────────────────────────┐
│                    User API (H2)                        │
│                                                         │
│  ┌──────────────────────────────────────────────────┐  │
│  │                    users                         │  │
│  ├──────────────────────────────────────────────────┤  │
│  │ PK  id (BIGINT)                                  │  │
│  │     provider (VARCHAR)                           │  │
│  │ UK  provider_id (VARCHAR)                        │  │
│  │     email (VARCHAR)                              │  │
│  │     nickname (VARCHAR)                           │  │
│  │     introduction (TEXT)                          │  │
│  │     profile_image (VARCHAR)                      │  │
│  │     status (VARCHAR)                             │  │
│  │     created_at (TIMESTAMP)                       │  │
│  │     updated_at (TIMESTAMP)                       │  │
│  └──────────────────────────────────────────────────┘  │
│                          │                              │
│                          │ user_id (JWT)                │
└──────────────────────────┼──────────────────────────────┘
                           │
┌──────────────────────────┼──────────────────────────────┐
│                    Catalog API (SQLite)                 │
│                          │                              │
│  ┌───────────────────────┼──────────────────────────┐  │
│  │                   catalogs                       │  │
│  ├──────────────────────────────────────────────────┤  │
│  │ PK  catalog_id (VARCHAR)                         │  │
│  │ FK  user_id (VARCHAR) ◄──────────────────────────┼──┘
│  │     title (VARCHAR)                              │
│  │     description (TEXT)                           │
│  │     category (VARCHAR)                           │
│  │     tags (JSON)                                  │
│  │     visibility (VARCHAR)                         │
│  │     thumbnail_url (VARCHAR)                      │
│  │     created_at (TIMESTAMP)                       │
│  │     updated_at (TIMESTAMP)                       │
│  └──────────────────────────────────────────────────┘
│                          │
│                          │ 1:N
│                          ▼
│  ┌──────────────────────────────────────────────────┐
│  │                     items                        │
│  ├──────────────────────────────────────────────────┤
│  │ PK  item_id (VARCHAR)                            │
│  │ FK  catalog_id (VARCHAR)                         │
│  │     name (VARCHAR)                               │
│  │     description (TEXT)                           │
│  │     image_url (VARCHAR)                          │
│  │     user_fields (JSON)                           │
│  │     created_at (TIMESTAMP)                       │
│  │     updated_at (TIMESTAMP)                       │
│  └──────────────────────────────────────────────────┘
│                          │
│                          │ 1:N
│                          ▼
│  ┌──────────────────────────────────────────────────┐
│  │              user_item_status                    │
│  ├──────────────────────────────────────────────────┤
│  │ PK  id (INTEGER)                                 │
│  │ FK  user_id (VARCHAR)                            │
│  │ FK  item_id (VARCHAR)                            │
│  │     owned (BOOLEAN)                              │
│  │     created_at (TIMESTAMP)                       │
│  │     updated_at (TIMESTAMP)                       │
│  │ UK  (user_id, item_id)                           │
│  └──────────────────────────────────────────────────┘
│
│  ┌──────────────────────────────────────────────────┐
│  │               user_catalogs                      │
│  ├──────────────────────────────────────────────────┤
│  │ PK  id (INTEGER)                                 │
│  │ FK  user_id (VARCHAR)                            │
│  │ FK  original_catalog_id (VARCHAR)                │
│  │ FK  copied_catalog_id (VARCHAR)                  │
│  │     saved_at (TIMESTAMP)                         │
│  │ UK  (user_id, original_catalog_id)               │
│  └──────────────────────────────────────────────────┘
└─────────────────────────────────────────────────────────┘
```

### 4.2 관계 설명

#### User ─ Catalog (1:N)
- 한 사용자는 여러 카탈로그를 소유할 수 있습니다.
- user_id는 JWT 토큰에서 추출되어 catalogs 테이블에 저장됩니다.
- 물리적 외래키는 없지만 논리적으로 연결됩니다.

#### Catalog ─ Item (1:N)
- 한 카탈로그는 여러 아이템을 포함할 수 있습니다.
- catalog_id로 연결됩니다.
- 카탈로그 삭제 시 연관 아이템도 함께 삭제됩니다.

#### User ─ Item ─ UserItemStatus (N:M)
- 한 사용자는 여러 아이템의 보유 상태를 가질 수 있습니다.
- 한 아이템은 여러 사용자의 보유 상태를 가질 수 있습니다.
- user_item_status 테이블이 중간 테이블 역할을 합니다.
- (user_id, item_id) 조합은 유일해야 합니다.

#### User ─ Catalog ─ UserCatalog (N:M)
- 한 사용자는 여러 카탈로그를 저장할 수 있습니다.
- 한 카탈로그는 여러 사용자에게 저장될 수 있습니다.
- user_catalogs 테이블이 중간 테이블 역할을 합니다.
- original_catalog_id: 원본 카탈로그
- copied_catalog_id: 복사본 카탈로그 (사용자의 컬렉션에 추가됨)

## 5. 데이터 타입 및 제약 조건

### 5.1 공통 규칙

- **UUID**: 36자 문자열 (8-4-4-4-12 형식)
- **Timestamp**: ISO 8601 형식 (YYYY-MM-DDTHH:MM:SS)
- **JSON**: 문자열로 저장, 파싱 후 사용
- **Boolean**: SQLite에서는 0/1로 저장

### 5.2 필수 필드

모든 테이블에 공통적으로 포함되는 필드:
- **created_at**: 레코드 생성 시간 (자동 설정)
- **updated_at**: 레코드 수정 시간 (자동 갱신)

### 5.3 인덱스 전략

- **Primary Key**: 모든 테이블에 PK 설정
- **Foreign Key Index**: 조인에 사용되는 컬럼에 인덱스 설정
- **Unique Index**: 중복 방지가 필요한 컬럼 조합에 설정
- **Search Index**: 검색에 자주 사용되는 컬럼에 인덱스 설정

## 6. 데이터 무결성

### 6.1 참조 무결성

- **User API ↔ Catalog API**: 물리적 외래키 없음 (마이크로서비스 독립성)
- **Catalog ↔ Item**: 애플리케이션 레벨에서 관리
- **User ↔ UserItemStatus**: 애플리케이션 레벨에서 관리

### 6.2 데이터 검증

- **User API**: Bean Validation (@NotNull, @Email 등)
- **Catalog API**: Pydantic 모델로 검증
- **Flutter**: 클라이언트 측 입력 검증

### 6.3 삭제 정책

- **User 삭제**: Soft Delete (status = 'DELETED')
- **Catalog 삭제**: Hard Delete (연관 Item도 함께 삭제)
- **Item 삭제**: Hard Delete (연관 UserItemStatus도 함께 삭제)

## 7. 데이터 마이그레이션

### 7.1 개발 환경

- **User API**: H2 인메모리 (재시작 시 초기화)
- **Catalog API**: SQLite 파일 (catalog.db)
- **마이그레이션**: 수동 SQL 스크립트

### 7.2 프로덕션 환경 (향후)

- **User API**: MySQL/PostgreSQL (RDS)
- **Catalog API**: DynamoDB
- **마이그레이션**: Flyway (User API), Alembic (Catalog API)

## 8. 데이터 백업

### 8.1 개발 환경

- **User API**: 백업 불필요 (인메모리)
- **Catalog API**: catalog.db 파일 복사

### 8.2 프로덕션 환경 (향후)

- **User API**: RDS 자동 백업
- **Catalog API**: DynamoDB Point-in-Time Recovery
- **백업 주기**: 일일 자동 백업
- **보관 기간**: 30일
